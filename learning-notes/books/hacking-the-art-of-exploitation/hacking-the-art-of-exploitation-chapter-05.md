**SUMMARY OF** 
**HACKERS: THE ART OF EXPLOITATION** 
*(SECOND EDITION) BY JON ERICKSON*

---

# CHAPTER 0x500: SHELLCODE

---

## 0x510. Assembly vs. C

* **What shellcode really is**: raw machine instructions for a specific CPU/OS ABI, typically written in assembly and executed *in-process* after exploitation.
* **C vs. assembly**:
  * C uses **standard libraries** that eventually make **kernel system calls**; the compiler/loader set up CRT/glue.
  * Assembly shellcode **omits libraries and CRT**; it directly invokes the kernel interface and must be **position-independent** and **self-contained** (no relocations).
* **Dev mindsets**:
  * C prioritizes readability/portability; assembly shellcode prioritizes **small size**, **no bad bytes** (e.g., `0x00`), and **reliable control transfer**.
* **Hello World comparison**:
  * C: `printf("Hello, world!\n")` → libc → `write(1, buf, len)`.
  * Assembly: load regs for `write`, issue a **syscall trap**, then `exit`. (See next subsection for Linux i386 register conventions.)

### 0x511. Linux System Calls in Assembly

* **i386 calling convention (Linux)**:
  * `EAX` = syscall number; `EBX, ECX, EDX, ESI, EDI, EBP` = args 1..6; return in `EAX`.
  * Trap with `int 0x80` (on modern x86_64: `syscall`, different arg regs).
* **Common calls in shellcode**:
  * `execve("/bin/sh", argv, envp)` (spawns a shell), `dup2(fd, i)` (stdio redirection), `exit(0)`, and networking via `socketcall` (i386).
* **Byte-safe encoding tricks**:
  * Instead of `mov eax, 0x0000000b` (encodes NULs), do `xor eax, eax; mov al, 0xb` **or** `push 0xb; pop eax`.
  * Use `cdq`/`xor edx, edx` to zero registers in **two bytes**.

---

## 0x520. The Path to Shellcode

* **From idea → bytes**:
  1. Write minimal **position-independent** assembly (no absolute addresses).
  2. **Stage data at runtime** (e.g., build strings on the stack) using the **jmp-call-pop** pattern to discover your current EIP.
  3. Remove relocations/glue; extract **raw opcodes** (e.g., with `objdump -d`/`ndisasm`) and test as an in-memory buffer.
  4. Iterate to eliminate **bad bytes** and shrink size.
* **Position independence**:
  * `jmp short label; ...; label: pop esi` yields the address of embedded data into a register.
* **Testing loop**: run tiny harnesses (C or Python) that call a function pointer to your buffer; attach `gdb` to verify regs/memory.

### 0x521. Assembly Instructions Using the Stack

* **String construction**:
  * Push dwords of the string **backwards** (little-endian) and **NUL-terminate** by pushing a zero.
  * Classic: push `"//sh"` (0x68732f2f) then `"/bin"` (0x6e69622f).
* **Argument vectors**:
  * Build `argv = { "/bin//sh", NULL }` on the stack; point `ECX` to it; set `EDX = 0` for `envp`.
* **Register setup**: `xor edx, edx` (envp NULL), `push 0xb; pop eax` (`execve`), `int 0x80`.

### 0x522. Investigating with GDB

* **Inspect flow**: `disas`, `si/ni` through `int 0x80`; confirm `EAX` (syscall), `EBX/ECX/EDX` (args), and memory layout for strings/argv.
* **Verify bytes**: dump your shellcode buffer (`x/20xb $esp-<len>`) to ensure it matches the intended instruction stream.
* **Crash-safety**: run inside a minimal harness (separate from your exploit) to debug logic before integration.

### 0x523. Removing Null Bytes

* **Why**: Many overflows/format paths treat `0x00` as terminator; NULs truncate payloads.
* **Patterns to avoid NULs**:
  * **Build immediates from small pieces**: `xor eax,eax; mov al, 0xb` instead of 32-bit immediates.
  * **Stack-based structs** (e.g., `sockaddr_in`) written via pushes/xors rather than static data.
  * **Arithmetic/logic synthesis**: produce needed constants with `add/sub/xor` or `inc/dec` sequences.
  * **Short-form ops**: prefer `push imm8` + `pop reg` over long immediates when possible.

---

## 0x530. Shell-Spawning Shellcode

* **Goal**: `execve("/bin//sh", {"/bin//sh", NULL}, NULL)` to hand control to a shell.
* **Minimal flow (i386)**:
  1. Place `"/bin//sh"` string on the **stack**; set `EBX` → string.
  2. Build `argv` on the stack (`[ptr_to_str, 0x0]`); set `ECX` → argv.
  3. `xor edx, edx` (envp = NULL).
  4. `eax = 11` (`execve`); `int 0x80`.
* **PIE tricks**: use `jmp-call-pop` to find the string if it’s embedded before/after code.

### 0x531. A Matter of Privilege

* **Effective UID rules**:
  * If the exploited binary is **setuid root**, your spawned shell inherits **EUID 0** (root) → privilege escalation.
  * Otherwise, the shell runs with the **target process’s** privileges; plan accordingly.
* **Environment hygiene**: sometimes clear or set environment variables to avoid restricted shells or logging hooks.

### 0x532. And Smaller Still

* **Size-golfing**:
  * Replace long immediates with `push imm8; pop reg` (e.g., `6A 0B` + `58`).
  * Reuse regs (e.g., `cdq` to zero `EDX`), and avoid redundant NUL pushes.
  * Encode strings as few dwords as possible; collapse setup with fall-through control flow.

---

## 0x540. PortBinding Shellcode

* **Purpose**: open a listening socket on a chosen port and attach a shell to the accepted connection.
* **High-level steps (Linux i386)**:
  1. `socket(AF_INET, SOCK_STREAM, 0)`
  2. `bind(fd, sockaddr_in{AF_INET, port, INADDR_ANY})`
  3. `listen(fd, backlog)`
  4. `accept(fd, 0, 0)` → returns client fd
  5. `dup2(client, 0/1/2)` to redirect stdio
  6. `execve("/bin//sh", argv, NULL)`
* **Kernel interface**: on i386 Linux, many net ops use **`socketcall`** (EAX=102) with **EBX=subcall** and **ECX=args pointer**; keep the argument blocks on the stack to avoid pointers to global data.
* **Operational note**: simple to use, but **exposes a listening port** defenders can notice.

### 0x541. Duplicating Standard File Descriptors

* **Redirection**:
  * Use `dup2(sock, 2)`, `dup2(sock, 1)`, `dup2(sock, 0)` (often in a small loop) so `/bin/sh` reads/writes over the network socket.
  * Loop pattern: load counter (e.g., `ecx=3`), then `dec ecx; int 0x80` until negative—compact and byte-friendly.

### 0x542. Branching Control Structures

* **Why branch**: tiny loops (for `dup2`), conditionals, and the **jmp-call-pop** trick for data discovery—all while staying position-independent.
* **Careful with jumps**: prefer **short jumps** to minimize size; avoid absolute addresses.

---

## 0x550. ConnectBack Shellcode

* **Purpose**: instead of listening, **connect back** to an attacker IP/port, then redirect stdio and exec a shell.
* **Pros/cons**:
  * **Bypasses inbound firewalls/NAT** (outbound often allowed), but embeds **attacker IP/port bytes** that must be chosen to avoid NULs.
* **Flow**:
  1. `socket(...)`
  2. Build remote `sockaddr_in` with **network-order** port/IP; `connect(fd, &sa, sizeof(sa))`
  3. `dup2` loop to map `fd` → `0/1/2`
  4. `execve("/bin//sh", ...)`
* **Stability**: test against varying environments; confirm no bad bytes in the packed IP/port.

---

## Summary author: **Jeremy Ray Jewell**
[GitHub](https://github.com/jeremyrayjewell)  
[LinkedIn](https://www.linkedin.com/in/jeremyrayjewell)
