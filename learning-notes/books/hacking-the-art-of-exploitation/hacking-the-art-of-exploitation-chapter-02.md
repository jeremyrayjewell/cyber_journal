**SUMMARY OF**
**HACKERS: THE ART OF EXPLOITATION**
*(SECOND EDITION) BY JON ERICKSON*

---

# CHAPTER 0x200: PROGRAMMING

---

## 0x210 What is Programming?

* **Dual nature of hacking**: writing elegant code and exploiting it share problem‑solving techniques.
* **Programming hacks** focus on inventive rules‑based solutions for efficiency and elegance—small, neat, inventive code.
* **Exploit hacks** use system rules to bypass security in unintended ways.
* **Business vs. hacker mindset**: commercial code prioritizes features over optimization; hackers relish optimization on constrained platforms (e.g., Commodore 64) and necessity of minimal exploits.

---

## 0x220 Pseudo-code

* **Definition**: informal, English‑like instructions structured like code; not machine‑readable, but clarifies algorithm logic.
* **Syntax flexibility**: varies by author; typically C‑style braces and semicolons for readability.

---

## 0x230 Control Structures

Without control structures, code is linear. Control structures alter flow based on conditions.

### 0x231 If‑Then‑Else

<pre markdown>
if (condition) {
    // execute when true
} else {
    // execute when false
}
</pre>

* Handles conditional branching (e.g., alternate driving routes when road blocked).
* Braces optional for single‑statement blocks, but recommended for clarity.

### 0x232 While/Until Loops

* **while**: repeat a block *while* a condition remains true.

<pre markdown>
while (hungry) {
find\_food();
eat\_food();
}
</pre>
- **until** (Perl syntax): repeat _until_ a condition becomes true—equivalent to `while (!condition)`.

### 0x233 For Loops  
- Iteration counter loops for fixed repetitions.  
<pre markdown>
for (i = 0; i < 5; i++) {
    drive_one_mile();
}
</pre>

* Equivalent to initializing a counter and using a `while` loop with increment.

---

## 0x240 More Fundamental Programming Concepts

Universal building blocks used across languages; shown here with C‑like syntax.

### 0x241 Variables

* **Definition**: named storage for data that can change; **constants** don’t.
* **Typed in C**: declare before use (e.g., `int`, `float`, `char`).
* **Examples**: `int a=13, b; float k=3.14f; char z='w'; b = a + 5;`
* **Mental model**: types guide the compiler’s layout/operations, but underneath it’s all bytes in memory.

### 0x242 Arithmetic Operators

* Operators: `+`, `-`, `*`, `/`, `%` (modulo → remainder).
* **Integer vs float division**: `13/5` → `2` as `int`; cast/use `float` to keep `2.6`.
* **Increment/Decrement**: `i++`, `++i`, `i--`, `--i`. Pre vs. post matters:

  * `b = a++ * 6;` ⇒ `b = a*6; a=a+1;`
  * `b = ++a * 6;` ⇒ `a=a+1; b=a*6;`
* **Compound assignment**: `+=`, `-=`, `*=`, `/=` for in‑place updates (e.g., `i += 12`).

### 0x243 Comparison Operators

* Relational: `<`, `>`, `<=`, `>=`, `==`, `!=` (**note**: `==` tests equality; `=` assigns).
* Logical: `||` (OR), `&&` (AND), `!` (NOT). Use parentheses to group.
* **Truthiness in C**: any nonzero is *true*, `0` is *false*; comparisons yield `1` or `0`.
* **Shorthand**: `while (hungry)` is equivalent to `while (hungry == 1)`.
* **Example**: `while (hungry && !cat_present) { if (!food_is_on_a_mousetrap) eat_food(); }`

### 0x244 Functions

* **Purpose**: package reusable steps; accept **parameters** and optionally **return** a value.
* **Signatures**: declared by return type and parameter types, e.g., `int factorial(int x);` (prototype).
* **Return & flow**: `return` hands a value back and ends the function; execution resumes after the call.
* **Void functions**: `void` when no value is returned (e.g., `void turn(dir, street)`).
* **Usage example**: `b = factorial(5); // b == 120`
* **Libraries**: much of C’s power comes from calling existing library functions.

---

## 0x250 Getting Your Hands Dirty

### 0x251 The Bigger Picture

* **Source vs. binary**: C source does nothing until **compiled** into an executable for a target CPU/OS.
* **Toolchain**: GCC translates C → machine code; default output is `a.out`, run with `./a.out`.
* **Headers & prototypes**: `#include <stdio.h>` supplies function prototypes (e.g., `printf`) so the compiler knows signatures.
* **Hello‑world loop**: a minimal `main()` prints "Hello, world!" 10× using a `for` loop and stdio.
* **Inspection**: `objdump -D` disassembles binaries; bytes are shown in **hex**, with each line an instruction at a **memory address**.
* **Architectures matter**: x86, SPARC, PowerPC each have different machine languages; compilers target one at build time.
* **Assembly dialects**: Linux tools default to **AT\&T** syntax; `-M intel` switches `objdump` to **Intel** syntax (often more readable).

### 0x252 The x86 Processor

* **Registers** (32‑bit names shown):

  * **General purpose**: `EAX` (accumulator), `EBX` (base), `ECX` (counter), `EDX` (data).
  * **Pointers/indexes**: `ESP` (stack pointer), `EBP` (base/frame pointer), `ESI` (source index), `EDI` (destination index).
  * **Control**: `EIP` (instruction pointer) indicates the next instruction; **`EFLAGS`** stores comparison/result flags.
* **Debugging with GDB**:

  * Set breakpoints (e.g., `break main`), `run`, then `info registers` to see CPU state.
  * Execution stops before your code; the compiler‑generated **function prologue** sets up the stack frame for locals.

### 0x253 Assembly Language

* **Syntax & form**: Intel style uses `op dest, src` (e.g., `mov ebp, esp`, `sub esp, 0x8`).
* **Core ops**: data movement (`mov`, `lea`), arithmetic (`add`, `sub`, `inc`), and control flow (`cmp`, conditional jumps like `jle`, unconditional `jmp`).
* **Loop mapping**: a C `for` loop compiles roughly to: init (`mov` to zero), test (`cmp` + `jle`), body (`call printf`), increment (`lea` + `inc`), and a back‑edge `jmp`.
* **Stack‑based calls**: arguments placed at `[esp]` (e.g., `mov DWORD PTR [esp], 0x8048484`), then `call printf`.
* **Finding strings**: use GDB `x/i` to disassemble at `EIP`; `x/s <addr>` reveals ASCII strings (e.g., `"Hello, world!
  "`).
* **Examining memory**: GDB `x/<count><format><size> <addr>` where formats include `x` (hex), `u` (unsigned), `o` (octal), `t` (binary), `i` (instruction), `c`/`s` (chars/strings). Sizes: `b`(1), `h`(2), `w`(4), `g`(8).
* **Endianness**: x86 is **little‑endian**—multi‑byte values are stored least‑significant byte first; GDB reverses bytes when displaying words/halfwords so numeric values read correctly.
* **Stepping**: `nexti` executes one instruction; watch `EIP`, memory at `[ebp-4]` (the local `int i`), and flags change as you step.

---

## 0x260 Back to Basics

Now that the idea of programming is less abstract, there are a few other important concepts inherited from C and low-level programming that shape higher‑level constructs. Assembly language and processor fundamentals predate modern languages, and understanding them deepens insight into languages like C.

### 0x261 Strings

* Strings in C are character arrays (buffers) terminated by a null byte (`�`).
* Manual assignment to each element is tedious; the standard library provides functions such as `strcpy()` to copy whole strings.
* Internally, strings occupy contiguous memory—functions stop at the first null byte.

### 0x262 Signed, Unsigned, Long, and Short

* By default, integer types in C are signed using two’s complement, allowing negative values.
* Unsigned types range from 0 to 2ⁿ−1; signed types range from −2ⁿ⁻¹ to 2ⁿ⁻¹−1.
* The `sizeof()` operator reveals type sizes on the target architecture.

### 0x263 Pointers

* Pointers hold memory addresses; passing addresses avoids expensive data copies.
* Declared by appending `*` to a type: `int *p` points to an integer.
* Pointer arithmetic scales by the pointed‑to type’s size.
* The address‐of operator (`&`) and dereference operator (`*`) navigate between addresses and values.

### 0x264 Format Strings

* `printf()` uses format specifiers (`%d`, `%u`, `%x`, `%s`, etc.) to print values of various types.
* Field width and padding (e.g., `%08x`) control alignment and zero‐padding.
* `%n` writes the byte count back into memory—an advanced (and exploitable) feature.
* `scanf()` mirrors `printf()`, but requires pointers for all arguments.

### 0x265 Typecasting

* Temporarily treat a value as another type with syntax `(new_type)value`.
* Useful for integer vs. floating‐point arithmetic to avoid truncation.
* Casting between pointer types overrides compiler checks; necessary for generic functions like `malloc()`.

### 0x266 Command‑Line Arguments

* `main(int argc, char *argv[])` gives access to command‑line parameters as strings.
* `argc` counts arguments; `argv[0]` is the program name.
* Conversion functions (e.g., `atoi()`) parse strings into numeric types.
* Always validate `argc` before accessing `argv[]` to prevent segmentation faults.

### 0x267 Variable Scoping

* Local variables exist per‐call on the stack; each function invocation has its own context.
* Global variables (outside functions) reside in fixed segments (`.data` or `.bss`).
* `static` variables retain values across calls while remaining local to their function.
* Understanding stack frames, backtraces, and variable addresses clarifies scope and lifetime.


---

## 0x270 Memory Segmentation

C programs are split into five segments with different purposes, sizes, and protections.

### 0x271 Memory Segments in C

* **Text (code)**: machine instructions. **Read‑only**, **fixed size**, shareable across processes. CPU executes a fetch–advance–execute loop using **EIP**; control‑flow (`jmp/call/ret`) simply moves EIP.
* **Data vs. BSS**: globals/statics live here. **Data** = *initialized* (writable, fixed size). **BSS** = *uninitialized*, zero‑filled at program start (also writable, fixed size).
* **Heap**: dynamic region managed by the allocator (`malloc`/`free`). In this book’s diagramming convention (small addresses shown at the *top*), the heap grows **down the page toward higher addresses**.
* **Stack**: per‑call **stack frames** hold *params → return address → saved frame pointer (SFP) → locals*. **ESP** tracks the top, **EBP** anchors the current frame. FILO/LIFO behavior. In this convention the stack grows **up the page toward lower addresses**, i.e., toward the heap.
* **Layout & growth**: from low → high addresses (top→bottom): **text → data → bss → heap … stack** (high end). Heap and stack grow toward each other to minimize wasted space.
* **Observed in code**: `memory_segments.c` prints addresses: initialized globals/statics in `.data`, uninitialized in `.bss`, `malloc()` blocks in the heap, and locals on the stack. Equal‑named locals in different functions occupy different frames; the later call’s `stack_var` has a numerically **smaller** address (consistent with stack growth toward lower addresses).

### 0x272 Using the Heap

* `malloc(size)`: reserves `size` bytes and returns a `void*`; **check for `NULL`** on failure and cast as needed.
* `free(ptr)`: releases a block; avoid leaks, double‑frees, and use‑after‑free.
* **Allocator behavior**: successive allocations typically show **increasing** heap addresses; freed space may be **reused** for a later allocation of a fitting size (as demonstrated by varying the first request in `heap_example.c`).
* **Diagnostics**: sample output prints `char_ptr`/`int_ptr` addresses; `fprintf(stderr, ...)` reports errors distinctly from normal output.

### 0x273 Error‑Checked malloc()

* Wrap allocation in a helper like `void *errorchecked_malloc(unsigned int size)` that:

  * calls `malloc(size)`,
  * on `NULL`, prints to `stderr` and `exit(-1)`,
  * otherwise returns the pointer.
* Add a prototype near the top; replace raw `malloc()` calls with the wrapper to keep code **DRY** and safer.

---

## 0x280 Building on Basics

These topics build on core C to interact with the OS, manage privileges, and compose larger programs.

### 0x281 File Access

* **File descriptors (FDs)**: small integers that refer to open files. Core POSIX calls:

  * `open(path, flags[, mode])` → returns FD or `-1` on error.
  * `read(fd, buf, n)`, `write(fd, buf, n)`, `close(fd)` → return bytes read/written or `-1` on error.
* **Flags** (from `<fcntl.h>`): access mode `O_RDONLY`, `O_WRONLY`, `O_RDWR`; modifiers `O_APPEND`, `O_TRUNC`, `O_CREAT` (requires a **mode** from `<sys/stat.h>`, e.g., `S_IRUSR|S_IWUSR`). Combine with **bitwise OR**.
* **Low‑level vs stdio**: unbuffered syscalls with FDs vs buffered streams (`FILE*`) in `<stdio.h>`. Book focuses on low‑level for clarity.
* **Example – `simplenote`**: allocates buffers, appends a CLI note to `tmpnotes` using `open(..., O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR)` then `write()`; uses `strlen()` for byte count and `perror()` in a `fatal()` helper.
* **Bitwise refresher**: OR (`|`) and AND (`&`) operate per‑bit; unique one‑bit flags compose safely (e.g., `O_WRONLY|O_APPEND|O_CREAT`).

### 0x282 File Permissions

* **Unix r/w/x for user, group, other**: shown by `ls -l`; changed with `chmod` (numeric like `731` or symbolic like `u+w`, `ugo-wx`).
* **Creation modes** (for `O_CREAT`): `S_IRUSR`, `S_IWUSR`, `S_IXUSR`, and group/other variants (`GRP`, `OTH`).
* **Setuid bit** (`chmod u+s`): executable runs with **owner’s** privileges.

  * Example: `chsh` is owned by root and setuid; can safely edit only the caller’s record in `/etc/passwd`.

### 0x283 User IDs

* **Real vs effective UID**: `getuid()` (who invoked), `geteuid()` (who you *run as*, after setuid).
* Demo: `uid_demo` shows both as caller’s UID; after `chown root` + `chmod u+s`, effective UID becomes `0` (root).
* **Multiuser notes**: `notetaker` (setuid root) writes `(userid, "
  ", note, "
  ")` to `/var/notes`; `notesearch` (also setuid) opens the file read‑only and prints only records with the caller’s UID (optionally filtered by a search string).

  * **Endianness**: integer UIDs are stored in binary; x86 little‑endian shows bytes reversed in hex dumps.
  * **`lseek(fd, -len, SEEK_CUR)`** rewinds to the start of the current line before reading it into a buffer.
* **Includes**: angle brackets search system headers (`<stdio.h>`); quotes search the local dir first (`"hacking.h"`) for shared helpers like `fatal()` and `ec_malloc()`.

### 0x284 Structs

* **Aggregates** of heterogeneous fields, e.g., `struct tm` in `<time.h>` with `tm_sec`, `tm_min`, …
* Access patterns: `s.field`; or via pointer `p->field`. Internals are contiguous but may include **padding**.
* **Pointer re‑interpretation**: casting a `struct tm*` to `int*` lets you read `tm_sec` at offset 0; educational but brittle—prefer named fields.
* Inspect memory with a byte dump to see adjacent fields; pointer arithmetic on typed pointers advances by element size.

### 0x285 Function Pointers

* Variables that hold **addresses of functions**. Declare like `int (*fp)(void);` then assign `fp = func_one;` and call `fp();`.
* Useful for callbacks, jump tables, and **pluggable behaviors** (e.g., current game selection).

### 0x286 Pseudo‑random Numbers

* Deterministic generators: `srand(seed)` then `rand()` → `0..RAND_MAX`.
* **Seed with** `time(NULL)` to vary across runs. Scale with modulo (e.g., `(rand()%20)+1` → `1..20`).
* Same seed ⇒ same sequence; true randomness requires external entropy.

### 0x287 A Game of Chance

* **Persistent user data**: `struct user { int uid, credits, highscore; char name[100]; int (*current_game)(); }` stored in `DATAFILE` under `/var`.
* **Setuid root** executable so multiple users can read/write the shared data safely.
* **Flow**: on start, `get_player_data()` searches the file for caller’s UID; if missing, `register_new_player()` appends a new record with 100 credits.
* **Games via function pointer** `player.current_game`:

  * **Pick a Number**: costs 10 credits; guess 1–20; jackpot +100 on exact hit.
  * **No Match Dealer**: deal 16 numbers (0–99); any duplicate ⇒ lose wager; no duplicates ⇒ win wager.
  * **Find the Ace** (Monty Hall): show 3 cards (two queens, one ace); reveal a queen; player can **switch** or **increase wager**; switching improves win odds.
* **Support routines**: `take_wager()` validates wagers vs credits; `update_player_data()` writes back credits/high score/name; `show_highscore()` scans all records; `input_name()` reads a full line safely; `print_cards()` renders cards.
* Demonstrates **FD I/O**, **structs**, **function pointers**, **PRNG**, **setuid**, and cautious input/validation in one cohesive program.

---


## Summary author: **Jeremy Ray Jewell**
[GitHub](https://github.com/jeremyrayjewell)
[LinkedIn](https://www.linkedin.com/in/jeremyrayjewell)
