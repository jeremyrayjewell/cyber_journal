**SUMMARY OF** 
**HACKING: THE ART OF EXPLOITATION** 
*(SECOND EDITION) BY JON ERICKSON*

---

# CHAPTER 0x300: EXPLOITATION

---

## 0x310 Generalized Exploit Techniques

**What exploitation is**

* Redirect a program’s execution—within its own rules—to do what *you* want. Bugs are design/logic oversights in code or in its environment (OS, encodings, toolchain).
* Computers follow the *letter* of the implementation, not intent (the “genie wish” idea).

**Classic logic pitfalls → footholds**

* **Off-by-one/fencepost**: miscounting items vs. gaps; inclusive ranges are `M - N + 1`.

  * *OpenSSH case*: bounds check used `id > channels_alloc` instead of `id >= channels_alloc` → allowed an out-of-bounds index and follow-on abuse.
* **Feature/encoding gaps**: new representations bypass old checks.

  * *IIS Unicode traversal*: `%5c` decoded to `\` **after** path validation → directory traversal outside web root; worms weaponized it.
* **Legal analogy (LaMacchia)**: systems execute rules as written; missing a case (non-commercial infringement) created a loophole until patched by the NET Act.

**General exploit pattern (big picture)**

1. **Trigger an unexpected case** (edge value, alternate encoding, oversized input).
2. **Corrupt a sensitive value in memory/state** (index, length, pointer, metadata).
3. **Seize control flow** (redirect where the CPU jumps/returns).
4. **Run arbitrary code** (payload in memory) *or* bend logic for unintended access.

**Common primitives that enable control-flow hijack**

* **Memory corruption**: overwrite data the program later *trusts*.

  * Typical targets: **return address**, **saved frame pointer (SFP/EBP)**, **function pointers**, **vtable pointers**, **length/flag fields** used in later security checks.
* **Buffer overflows** (covered next): write past a buffer boundary to reach those targets.
* **Format-string bugs** (covered next): attacker-controlled format strings let you **read/write arbitrary memory** (e.g., via `%n`).

**Why it often just crashes—unless crafted**

* Uncontrolled bad input corrupts random data → segfault.
* Carefully shaped input steers the overwrite to deterministic locations (e.g., stack frame layout) so the next `ret` or indirect call jumps to attacker-chosen code instead of the abyss.

**Key mindset**

* Look for places where **what was implemented ≠ what was intended** (edge bounds, ordering of checks vs. use, decoding/normalization done in the wrong phase).
* Small, “obvious” oversights can cascade into total compromise once you understand the execution model and memory layout.

---

## 0x320 Buffer Overflows

* **Core idea**: user input is copied into a fixed-size buffer without proper bounds checking; extra bytes **overflow** into adjacent memory.
* **Why it matters**: on typical call stacks the **saved return address** sits next to local buffers—so an overflow can **replace the return address**, hijacking execution when the function returns.
* **Reliable exploitation requires**: knowing the exact **offset** from buffer start to the saved return address, avoiding **bad characters** that terminate input, and placing executable code (or a jump target) at a predictable address.

### 0x321 Stack-Based Buffer Overflow Vulnerabilities

* **Typical vulnerable patterns**: `gets`, `strcpy`, `strcat`, `scanf("%s")`, or any copy that trusts the source length.
* **Stack frame anatomy (x86 mental model)**: arguments → saved return address → saved `EBP` → locals → buffers. Overflowing a local array can clobber `EBP` and then the **saved return address**.
* **Exploit recipe**:
  1. **Crash and measure**: send a long cyclic pattern; use the crash context to compute the exact overwrite **offset**.
  2. **Place payload**: store shellcode in the stack/heap/environment/argv; include a **NOP sled** to widen the landing zone.
  3. **Redirect control**: overwrite the saved return address with an address inside your payload/sled (respecting endianness).
  4. **Stabilize**: pin environment, keep input length constant, and align the stack so landing addresses are repeatable.
* **Failure modes**: random crashes (wrong offset), bad bytes truncating the input, misaligned returns; fix by tightening the byte count and testing iteratively under `gdb`.

---

## 0x330 Experimenting with BASH

* **Rapid input generation**: use quick one-liners to create long strings (e.g., `python -c "print('A'*600)"`, `perl -e 'print \"A\"x600'`), or cyclic patterns for offset discovery.
* **Automate the loop**: script length sweeps and capture `gdb` output to converge on the overwrite boundary quickly; redirect stdin/argv/env to test multiple surfaces.

### 0x331 Using the Environment

* **Why env works**: environment variables are mapped into process memory at relatively stable locations; you can stash shellcode there.
* **Technique**: set a large variable filled with a **NOP sled** and shellcode, then overwrite the return address with a pointer into that region.
* **Address tuning**: pad with extra dummy variables or arguments to shift addresses until the jump lands reliably.

---

## 0x340 Overflows in Other Segments

* **Not only the stack**: heap and global segments (**.data/.bss**) also hold **control data** (structs with function pointers, callback tables, etc.).
* **Strategy**: overflow one object to corrupt **adjacent metadata** (heap chunk headers) or **nearby pointers** the program will later dereference.

### 0x341 A Basic Heap-Based Overflow

* **Allocator basics**: each heap block has headers (size/flags). Overwriting a neighbor’s header can make `free`/`realloc` perform unintended **pointer writes** during coalescing/unlinking.
* **Primitive achieved**: convert a linear overflow into an **arbitrary write** (write an attacker-chosen value to an attacker-chosen address), which you then aim at a code-path pointer (GOT entry, function pointer, vtable slot).

### 0x342 Overflowing Function Pointers

* **Target class**: structs in `.data/.bss` or on the heap that include fields like `int (*fp)(...)`.
* **Exploit flow**: overflow a nearby buffer → overwrite the function pointer with the address of your shellcode (or a useful library routine) → when the program calls `fp()`, execution jumps to your address.

---

## 0x350 Getting Your Hands Dirty

* **Goal**: turn read/write primitives into deterministic control of execution. The format-string family is a direct path to **info leak** and **arbitrary write** when the format string itself is attacker-controlled.

### 0x351 Format Parameters

* **Format anatomy**: `%[flags][width][.precision][length]specifier` (e.g., `%08x`, `%-20s`, `%hn`).
* **Stack consumption**: each specifier generally pulls the **next argument** from the stack; the exact size depends on the length modifier (`h`, `hh`, `l`, etc.).
* **Implication**: by choosing specifiers carefully, you can read arbitrary stack words or shape the number of bytes printed to set up `%n` writes.

### 0x352 The Format String Vulnerability

* **Vulnerable pattern**: using untrusted input *as the format* (e.g., `printf(user_input)`), not merely as data (`printf("%s", user_input)`).
* **Impacts**:
  * **Information disclosure** (`%x/%p/%s`) exposes stack contents and pointed-to memory.
  * **Arbitrary write** via `%n` stores the current **byte count printed** into an address you control.

### 0x353 Reading from Arbitrary Memory Addresses

* **Method**: place a **target address** somewhere the function will treat as an argument (stack/heap), then use `%s` (dereference) or walk with `%x` until you reach it.
* **Stabilization**: use **positional parameters** to select the exact argument slot rather than guessing stack depth.

### 0x354 Writing to Arbitrary Memory Addresses

* **Using `%n`**: put the **address to write to** in an argument slot; print padding so the total characters output equals the desired value, then invoke `%n` to store it.
* **Practical notes**: avoid huge paddings by performing **partial writes** (see short writes) and ordering writes by ascending target values to minimize wraparounds.

### 0x355 Direct Parameter Access

* **Syntax**: `%m$<spec>` selects the **m-th** argument explicitly (e.g., `%7$x`, `%10$n`).
* **Why it matters**: removes guesswork about stack layout, making exploits much more reliable across runs and environments.

### 0x356 Using Short Writes

* **Specifiers**: `%hn` writes a 16-bit half-word; `%hhn` writes a single byte.
* **Strategy**: write multi-byte values in **pieces** (low → high) so each piece only needs a small, manageable padding.

### 0x357 Detours with .dtors

* **`.dtors` (destructors) section**: an array of function pointers the runtime calls at program exit.
* **Exploit**: overwrite a `.dtors` entry with your payload address; the process appears to exit normally, then **invokes your code**.

### 0x358 Another notesearch Vulnerability

* **Context**: the sample `notesearch` utility (previously used to show setuid and file-parsing issues) also contains a **format-string** bug.
* **Leverage**: use its verbose printing pathway to leak addresses (defeating ASLR-like uncertainty) and then perform `%n`-based writes to seize control more cleanly than with a raw overflow.

### 0x359 Overwriting the Global Offset Table

* **GOT/PLT refresher**: dynamically linked calls look up the real function address via the **GOT**; the **PLT** stub jumps through that entry.
* **Exploit**: once you have an **arbitrary write**, overwrite a GOT entry (e.g., `printf@GOT`) with the address of your shellcode or a desired routine (like `system`).
* **Effect**: the next call to that function transparently **jumps to attacker-chosen code** for the lifetime of the process.

---

## Summary author: **Jeremy Ray Jewell**
[GitHub](https://github.com/jeremyrayjewell)
[LinkedIn](https://www.linkedin.com/in/jeremyrayjewell)

