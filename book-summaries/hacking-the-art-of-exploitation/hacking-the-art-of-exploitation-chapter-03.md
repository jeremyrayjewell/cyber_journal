SUMMARY OF 
**HACKERS: THE ART OF EXPLOITATION** 
(SECOND EDITION) BY JON ERICKSON

---

# CHAPTER 0x300: EXPLOITATION

---

## 0x310 Generalized Exploit Techniques

**What exploitation is**

* Redirect a program’s execution—within its own rules—to do what *you* want. Bugs are design/logic oversights in code or in its environment (OS, encodings, toolchain).
* Computers follow the *letter* of the implementation, not intent (the “genie wish” idea).

**Classic logic pitfalls → footholds**

* **Off‑by‑one/fencepost**: miscounting items vs. gaps; inclusive ranges are `M - N + 1`.

  * *OpenSSH case*: bounds check used `id > channels_alloc` instead of `id >= channels_alloc` → allowed an out‑of‑bounds index and follow‑on abuse.
* **Feature/encoding gaps**: new representations bypass old checks.

  * *IIS Unicode traversal*: `%5c` decoded to `\` **after** path validation → directory traversal outside web root; worms weaponized it.
* **Legal analogy (LaMacchia)**: systems execute rules as written; missing a case (non‑commercial infringement) created a loophole until patched by the NET Act.

**General exploit pattern (big picture)**

1. **Trigger an unexpected case** (edge value, alternate encoding, oversized input).
2. **Corrupt a sensitive value in memory/state** (index, length, pointer, metadata).
3. **Seize control flow** (redirect where the CPU jumps/returns).
4. **Run arbitrary code** (payload in memory) *or* bend logic for unintended access.

**Common primitives that enable control‑flow hijack**

* **Memory corruption**: overwrite data the program later *trusts*.

  * Typical targets: **return address**, **saved frame pointer (SFP/EBP)**, **function pointers**, **vtable pointers**, **length/flag fields** used in later security checks.
* **Buffer overflows** (covered next): write past a buffer boundary to reach those targets.
* **Format‑string bugs** (covered next): attacker‑controlled format strings let you **read/write arbitrary memory** (e.g., via `%n`).

**Why it often just crashes—unless crafted**

* Uncontrolled bad input corrupts random data → segfault.
* Carefully shaped input steers the overwrite to deterministic locations (e.g., stack frame layout) so the next `ret` or indirect call jumps to attacker‑chosen code instead of the abyss.

**Key mindset**

* Look for places where **what was implemented ≠ what was intended** (edge bounds, ordering of checks vs. use, decoding/normalization done in the wrong phase).
* Small, “obvious” oversights can cascade into total compromise once you understand the execution model and memory layout.

---

## 0x320 Buffer Overflows

### 0x321 Stack-Based Buffer Overflow Vulnerabilities

---

## 0x330 Experimenting with BASH

### 0x331 Using the Environment

---

## 0x340 Overflows in Other Segments

### 0x341 A Basic Heap-Based Overflow

### 0x342 Overflowing Function Pointers

---

## 0x350 Getting Your Hands Dirty

### 0x351 Format Parameters

### 0x352 The Format String Vulnerability

### 0x353 Reading from Arbitrary Memory Addresses

### 0x354 Writing to Arbitrary Memory Addresses

### 0x355 Direct Parameter Access

### 0x356 Using Short Writes

### 0x357 Detours with .dtors

### 0x358 Another notesearch Vulnerability

### 0x359 Overwriting the Global Offset Table


---

## Summary author: **Jeremy Ray Jewell**
[GitHub](https://github.com/jeremyrayjewell)
[LinkedIn](https://www.linkedin.com/in/jeremyrayjewell)
