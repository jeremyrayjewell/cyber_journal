**SUMMARY OF**
**HACKERS: THE ART OF EXPLOITATION**
*(SECOND EDITION) BY JON ERICKSON*

---

# CHAPTER 0x200: PROGRAMMING

---

## 0x210 What is Programming?

* **Dual nature of hacking**: writing elegant code and exploiting it share problem‑solving techniques.
* **Programming hacks** focus on inventive rules‑based solutions for efficiency and elegance—small, neat, inventive code.
* **Exploit hacks** use system rules to bypass security in unintended ways.
* **Business vs. hacker mindset**: commercial code prioritizes features over optimization; hackers relish optimization on constrained platforms (e.g., Commodore 64) and necessity of minimal exploits.

---

## 0x220 Pseudo-code

* **Definition**: informal, English‑like instructions structured like code; not machine‑readable, but clarifies algorithm logic.
* **Syntax flexibility**: varies by author; typically C‑style braces and semicolons for readability.

---

## 0x230 Control Structures

Without control structures, code is linear. Control structures alter flow based on conditions.

### 0x231 If‑Then‑Else

<pre markdown>
if (condition) {
    // execute when true
} else {
    // execute when false
}
</pre>

* Handles conditional branching (e.g., alternate driving routes when road blocked).
* Braces optional for single‑statement blocks, but recommended for clarity.

### 0x232 While/Until Loops

* **while**: repeat a block *while* a condition remains true.

<pre markdown>
while (hungry) {
find\_food();
eat\_food();
}
</pre>
- **until** (Perl syntax): repeat _until_ a condition becomes true—equivalent to `while (!condition)`.

### 0x233 For Loops  
- Iteration counter loops for fixed repetitions.  
<pre markdown>
for (i = 0; i < 5; i++) {
    drive_one_mile();
}
</pre>

* Equivalent to initializing a counter and using a `while` loop with increment.

---

## 0x240 More Fundamental Programming Concepts

### 0x241 Variables

### 0x242 Arithmetic Operators

### 0x243 Comparison Operators

### 0x244 Functions

---

## 0x250 Getting Your Hands Dirty

### 0x251 The Bigger Picture

### 0x252 The x86 Processor

### 0x253 Assembly Language

---

## 0x260 Back to Basics

Now that the idea of programming is less abstract, there are a few other important concepts inherited from C and low-level programming that shape higher‑level constructs. Assembly language and processor fundamentals predate modern languages, and understanding them deepens insight into languages like C.

### 0x261 Strings

* Strings in C are character arrays (buffers) terminated by a null byte (`�`).
* Manual assignment to each element is tedious; the standard library provides functions such as `strcpy()` to copy whole strings.
* Internally, strings occupy contiguous memory—functions stop at the first null byte.

### 0x262 Signed, Unsigned, Long, and Short

* By default, integer types in C are signed using two’s complement, allowing negative values.
* Unsigned types range from 0 to 2ⁿ−1; signed types range from −2ⁿ⁻¹ to 2ⁿ⁻¹−1.
* The `sizeof()` operator reveals type sizes on the target architecture.

### 0x263 Pointers

* Pointers hold memory addresses; passing addresses avoids expensive data copies.
* Declared by appending `*` to a type: `int *p` points to an integer.
* Pointer arithmetic scales by the pointed‑to type’s size.
* The address‐of operator (`&`) and dereference operator (`*`) navigate between addresses and values.

### 0x264 Format Strings

* `printf()` uses format specifiers (`%d`, `%u`, `%x`, `%s`, etc.) to print values of various types.
* Field width and padding (e.g., `%08x`) control alignment and zero‐padding.
* `%n` writes the byte count back into memory—an advanced (and exploitable) feature.
* `scanf()` mirrors `printf()`, but requires pointers for all arguments.

### 0x265 Typecasting

* Temporarily treat a value as another type with syntax `(new_type)value`.
* Useful for integer vs. floating‐point arithmetic to avoid truncation.
* Casting between pointer types overrides compiler checks; necessary for generic functions like `malloc()`.

### 0x266 Command‑Line Arguments

* `main(int argc, char *argv[])` gives access to command‑line parameters as strings.
* `argc` counts arguments; `argv[0]` is the program name.
* Conversion functions (e.g., `atoi()`) parse strings into numeric types.
* Always validate `argc` before accessing `argv[]` to prevent segmentation faults.

### 0x267 Variable Scoping

* Local variables exist per‐call on the stack; each function invocation has its own context.
* Global variables (outside functions) reside in fixed segments (`.data` or `.bss`).
* `static` variables retain values across calls while remaining local to their function.
* Understanding stack frames, backtraces, and variable addresses clarifies scope and lifetime.


---

## 0x270 Memory Segmentation

### 0x271 Memory Segments in C

### 0x272 Using the Heap

### 0x273 Error-Checked malloc()

---

## 0x280 Building on Basics

### 0x281 File Access

### 0x282 File Permissions

### 0x283 User IDs

### 0x284 Structs

### 0x285 Function Pointers

### 0x286 Pseudo-random Numbers

### 0x287 A Game of Chance


---

## Summary author: **Jeremy Ray Jewell**
[GitHub](https://github.com/jeremyrayjewell)
[LinkedIn](https://www.linkedin.com/in/jeremyrayjewell)
